{
  "name": "fcombine",
  "version": "0.0.4",
  "description": "function utility library",
  "keywords": [
    "function",
    "f",
    "arch",
    "utility"
  ],
  "author": {
    "name": "Jake Verbaten",
    "email": "raynos2@gmail.com"
  },
  "dependencies": {},
  "repository": {
    "type": "git",
    "url": "git://github.com/Raynos/fcombine.git"
  },
  "main": "src/f",
  "engines": {
    "node": "0.6.x"
  },
  "devDependencies": {
    "tester": "0.0.4"
  },
  "readme": "# f <a name=\"_f\" href=\"#_f\"><small><sup>link</sup></small></a>\r\n\r\nA function combination utility,\r\n\r\n## Blog posts <a name=\"Blog_posts\" href=\"#Blog_posts\"><small><sup>link</sup></small></a>\r\n\r\nComing soon!\r\n\r\n## Examples <a name=\"Examples\" href=\"#Examples\"><small><sup>link</sup></small></a>\r\n\r\n - [error annotated code][1] Coming soon!\r\n\r\n## Documentation <a name=\"Documentation\" href=\"#Documentation\"><small><sup>link</sup></small></a>\r\n\r\nAnnotated source code coming soon.\r\n\r\n### f.combine(f1, f2, flags) <a name=\"f.combine\" href=\"#f.combine\"><small><sup>link</sup></small></a>\r\n\r\n`f.combine` combines two functions. It will return a new function that invokes the\r\ntwo functions passed with `this` and `arguments`. \r\n\r\nThe `flags` object is an optional hash to set the value `pre` to true. If `pre` is true then f1 comes before f2 and f2 is considered the main function otherwise f1 is the main function. The returned function's length property matches the length property of the main function. The returned function also only returns the return value of the main function\r\n\r\n\tvar g = f.combine(function (a, b) {\r\n\t\tconsole.log(\"bar\")\r\n\t\treturn 42;\r\n\t}, function (a,b,c) {\r\n\t\tconsole.log(\"foo\")\r\n\t});\r\n\r\n\tg(); // \"bar\", \"foo\", returns 42\r\n\tg.length === 2; // true\r\n\r\n\tvar h = f.combine(function () {\r\n\t\treturn \"no value\";\r\n\t}, function (a,b,c,d) {\r\n\t\treturn \"magic\";\r\n\t}, { pre: true });\r\n\r\n\th(); // \"magic\"\r\n\th.length === 4; // true\r\n\r\n### f.compose(f1, f2, flags)\r\n\r\n`f.compose` composes two functions. It will return a new function that is the composition of f1 and f2. f1 is expected to return an array of arguments to pass \r\nto f2.\r\n\r\nThe optional `flags` hash can contain the `pre` flag to true which set's f2 to the main function, otherwise f1 is the main function. The returned function's length property is the same as the length property of the main function\r\n\r\n\tvar g = f.compose(function addOne(val) {\r\n\t\treturn [1, val];\r\n\t}, function (a, b) {\r\n\t\treturn a + b;\r\n\t});\r\n\r\n\tg(5); // 6\r\n\tg.length === 1; // true\r\n\r\n\tvar g = f.compose(function multiplyTwo(val) {\r\n\t\treturn [2, val];\r\n\t}, function (a, b) {\r\n\t\treturn a * b;\r\n\t}, { pre: true });\r\n\r\n\tg(5); // 10\r\n\tg.length === 2; // true\r\n\r\n### f.post(f1, f2) \r\n\r\nSugar for f.combine(f1, f2). Basically returns a new function where f2 comes after f1. (f1 being the main function)\r\n\r\n### f.pre(f1, f2)\r\n\r\nSugar for f.combine(f1, f2, { pre: true }). Basically return a new function where f1 comes before f2. (f2 being the main function)\r\n\r\n### f.extendNatives()\r\n\r\nextends Native objects with sugar. Specifically Function.prototype.pre and Function.prototype.post are mapped to f.pre and f.post respectively. \r\n\r\n### Function.prototype.pre(f)\r\n\r\nCalls f.pre(f, this) and returns a new function which calls f before this.\r\n\r\n### Function.prototype.post(f)\r\n\r\nCalls f.post(this, f) and returns a new function which calls f after this.\r\n\r\n   [1]: github.com/raynos/error",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Raynos/fcombine/issues"
  },
  "_id": "fcombine@0.0.4",
  "dist": {
    "shasum": "cd76168c9c4f2dcb637b78a03d6c80e15c919155"
  },
  "_from": "fcombine@0.0.4",
  "_resolved": "https://registry.npmjs.org/fcombine/-/fcombine-0.0.4.tgz"
}
